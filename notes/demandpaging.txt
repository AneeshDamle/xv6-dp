===============================================================================
Abhijit's take on the project:
===============================================================================
Implement demand paging in xv6
- invalid entry may have 2 meanings - page is out of range of addresses, 
                                      or not in memory
- implement backing store, requires knowing disk IO, maybe add one more disk
- devise a scheme for mapping pages to backing store
- write functions to do I/O for pages - will use disk driver code (exists)
- (IMP) restart of an instruction - this will necessiate a deeper study of x86
  instructions
- modify the frame allocation to some extent - ensure minimum frames for a
  process
- Ideally should be implemented such that:
    - the pages of a process get mapped identically with the way the file data
      in operating systems gets mapped
    - i.e. unified page cache - single way of handling mmap and buffers of
      files --> IGNORE
    - will be challenging, but if done, nothing better than this for learning
      number of OS concepts

===============================================================================
Notes from Abhijit Sir
===============================================================================

Demand paging
----
Spend little time reading x86 documentation to understand PTE flags!
let's say you will do pure demand paging.

Modify all the code in vm.c that sets up page table mappings to NOT TO ALLOCATE any frame, and make a PT entry that is invalid!.

Which hardware interrupt?  
need to read more about interrupt handling in xv6 , available in the xv6 book, on how to get a new hardware interrupt number. 

Then you add an option in trap()
the handler function will be your demand pager.

pager:
Allocate a frame (assume a very simple replacement algo) 
//then issue a read . HOW? How to determine what the PF was for?
to take the above decision, maintain may be additional information in struct proc! 
If it's the code, then you need to call readi() on inode of the executable 
If it's the heap/stack, etc: You need to call readbackingstore();
Update the page table;
RESUME the process! 

readbackingstore():
	needs to call the DD
	requires a third disk! 

xv6 DD supports only 2 disks as of now!
Modify the xv6 DD - I will tell you how to do that!

===============================================================================
My own understanding
===============================================================================
- Whenever a process has to run, all of its code is loaded in the RAM from
  disk, in the form of pages.
- This is inefficient as most of the code isn't needed on processor right now
- Hence, best way would be including only pages that are needed.
- This is demand paging.

Q. How to implement demand paging?
- Consider that a process is selected to run by scheduler.
- While loading the process, only some first pages are loaded
- Here, in the process's page table, a page can have valid/invalid flag:
  a. valid bit: page is for process and is loaded in RAM
  b. invalid bit: either page is not of process's virtual memory, or is but
  isn't loaded
- So, if the process wants to access a page that isn't loaded, a "page fault"
  will occur.
  - This is treated as a trap (and we already have a trap-handle)!
    And we will need a new interrupt handler to handle "this" new trap option.

NOTE: pure demand paging: never bring a page into memory until it is required.

===============================================================================
BACKING STORE DISCUSSIONS
===============================================================================
Now, we have implemented page fault handler for handling normal ELF loads

Q. What to do when the RAM is full?
- Select a victim page from RAM
- Write this victim page to the backing store, and add the free frame to
  kmem.freelist
- Then, kalloc() should return the same page

Our approach:
-------------
To make testing the working simple, we restrict each process to n pages in RAM
We store the virtual addresses of pages in bs in 1 table, in RAM in another
To remember which pages have been written to in the bs, we maintain a bitmap
of actual bs pages

Q1. How to select a victim page?
- We are implementing demand paging only for user processes
- We'll implement a preliminary random allocator:), and get a physical page
  address randomly (using randint ;)
- NOTE: Any user process page could be selected (Stack/Heap/Code/Data)

Q2. How to write it to the backing store?
- Optimzation 102: We could maintain a list of "free pages in BS" in Kernel Memory
- Take out the first free page, disk I/O will write a page to the BS
- Update the free list, and also the process's mmuinfo

Q3. How to read on a page fault?
- We first check whether the page fault is on a stack/heap (HOW TO ?), or
  code/data.
- If it's on code/data, find a free frame, then check if page content is on backing
  store OR not, and load it respectively from BS(readbackingstore) or
  ELF(readi - already written)
- If it's on stack/heap, find a free frame, search in bs and write, if not,
  just assign and return
- NOTE: In xv6, conceptually, only 1 stack page is allocated to each process

Further Optimizations:
- Optimization 101: If page is of TEXT section, avoid write to backing-store
  --> DONE
- Optimization 102: Modified bit for deciding to store/not in BS
- Optimization 103: LRU DLL for optimised page replacement algo

